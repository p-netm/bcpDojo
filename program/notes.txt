"""                                     NOTES
CONSIDERATIONS:

3 using mock module to simulate a user's input for successful testing -->

6. in several places i find that using the with keyword will shorten code; this are esp. areas
    in operning and reading files



8. remove the broker stage between the application and the database, the stage where there is pending
data within the system that is yet to be commited, this is to help secure against system failure.
9. a user cannot load state unless he/she has saved the state --> to avoid session data collision
10. quiz: if we tried saving data that is already in the database what happens

12. there is the conundrum of how to get an id from a person's name: see several people could share a
same name and if we were to use a name to extract the person id i think it would be futile --> i think
we can have a retrieve_id method that returns all ids of people who have a certain name
13. add unsopperted document formats. like say except for txt and csv throw an error
14 Refractor test files
15. the names of People and room_names are Nouns and should be capitalized, show some respect
16. that on loading people from a file should not display or those many confirmation messages but maybe a few
   where the names of people say assigned a particular office are listed in the confirmation message as a sequence
17. it so happens that you can load people from the same txt file several times, how can this be avoided???
18. see to it that display function displays data in a tabulated form


                            ADDITIONAL FEATURES
1.add text conditional coloring
2. consider adding  a gui

5.modify person: flags: remove_person, modify any property of a person's data including the id, name, and
    occupation. the last however is onedirectional, only fellows can become staff and nor vice versa
6.Print_room: considerations : the general output lookout, add csv output support, add printing capabilities
7.Print_allocations: styling, csv output support; add physical print capabilities
8. print_unallocations: styling, consider csv output; consider physical print
9: reallocate Person level seems not to have a way in which it can be upgraded
10. load_people: Addd csv input capabilities,

                                        RESOLVED
 3. rename_room
4. delete_room
    maybe we can say modify room with optional flags that specify whether rename or delete

1 the reallocate person should have also been used to allocate unallocated persons to a room.
2 i also think that the os.path module can help simplify on the functionality of testing to see
if a certain file is existent.
5. the return boolean value for sel.id_is_present are inverted
4 the add_person maybe can have a fourth parameter that takes in a person's id => the problem
    is that if we say that a person can be assigned an id after their objects are initialised then
    that would mean that we are not fully initialising our objects. -> resolved

2.8 Also on a same note, there is the question that where should a file be so that it can be accessed
 by the system; i mean is there some specific place where the user must place a file that is being used
 by the system and in what way can we make this process more dynamic and more user friendly

 12 i find there is still an issue with input file loaded data because of person ids; i think i
     the way about this randomising the id process where one is not given
    """
19 a fellow having a living space but no office --> then he would be in the unllalocated list but not in the
unallocated living list
7. just a thought, whatif the person's object did track their allocation status i think this would
be quite computationaly significant.
11. correcty review the logic of especially how fellow who requested accomodation and did not recieve
is handled when being saved to the database as well as being retrieved

ok here is a thought: see modification of objects could be much more safe and unvulnerable if there was a way
like in c++ where variable names of connections such as a person belonging to a room can be dynamically tracked
each time that room_names or equivalent attributes are needed. Soo like i should try and avoid hard coding relationships
, as in retrieveal of such connected or rather information can be retrieved via reference. so say person track which office
and space that they are located. then retrieving the office_names we can build a set of all office_properties for all people
and so the same case for living_space. but in this case if we change say the office name then we have to loop through the
people's office_allocation property and reassign this property. Am looking for a situation where i need changing
data only in one place and the same change should reflect across every point where that specific data is referenced. ok..
so what if we also have room objects that track their room. so a person object will like track a room_object instead of the room name
. the philosophy behind this approach is that a person knows what rooms he belongs to but a room has no mind for knowing
who has been allocated to it. Maybe we can help the room by setting up a trigger whereby after a person is added to the room
one of its other properties that we shall occupants_no is updated.